# 一起来画圆 - Drawing Circles : 文档说明

## 玩法

1. 进入<a href="./index.html">该网站</a>，然后用鼠标或者手指在屏幕上画圆。
2. 算法将自动拟合圆形并计算各个参数，反映你画的圆的好坏。

## 结果说明

1. 如果新绘制的轨迹直接消失，意味着你绘制的图案绕中心不止一圈。我们拒绝处理这这种鬼画符。
2. 红色十字形处为圆形位置；红色圆为标准圆。
3. 经过圆形的双箭头，表示你绘制的圆形主要在什么方向上有所伸长（或者在与之垂直的方向上有所压缩）。
4. 左下角提供了更多有关你绘制的圆形的参数：
  - 方向(direction)：你的轨迹是顺时针还是逆时针转；
  - 分数(score)：用与标准的圆形的符合程度为你绘制的圆形打分。*GPA沿用2025年绩点改革以前北京大学的绩点计算方式。*
  - 偏差(deviation)：你的轨迹与标准圆形偏离距离的*方均根平均值*
  - 半径(radius)：你的轨迹与中心点的的平均距离
  - 粗糙度(roughness)：你的轨迹与标准圆形的偏离*有多少成分*是手抖造成的
  - 开发者(developer)：*关注<a href="https://github.com/Joat917">我</a>喵，谢谢喵~（摇尾巴）*
5. 频谱的0~36倍频分量被绘制在屏幕下方，它代表与圆的偏离模式每一圈发生多少次。*例如，如果你画了一个正三角形，频谱的3倍频分量会很高；如果你画了正方形或者四芒星，那么4倍频分量会很高。*
    
## 算法简介

#### 一、数据采集

当你的鼠标或者手指在屏幕上拖动的时候，曲线上各点的坐标以$(x,y)$（单位：像素(pixel)）的格式存储在浏览器本地的一个数组中。*请放心，画圆功能完全由Javascript实现，没有后端，更不可能存在所谓的数据泄露。*

如果新绘制的曲线（即上述数组）被判定为不合格，即绕中心点的圈数不是$\pm1$，那么它将被直接抛弃。只有当该曲线被判定为合格时，它才会覆盖旧的绘制记录，并显示在屏幕上。

#### 二、数据处理

1. 重采样。我们首先在曲线上重新采样，使得相邻两个点的距离适中，以保障后续积分中的精确度与时效性。
2. 微元计算。每个点$\vec{p}_i$都对应一个长度微元$d s_i$，其计算公式为$$d s_i=(||\vec{p}_i-\vec{p}_{i-1}||+||\vec{p}_{i+1}-\vec{p}_i||)/2$$
3. 估计圆心。根据质心位置估算，圆心大致位于$$\vec{c}_0=\oint\vec{p}_i ds_i$$
4. 计算缠绕数。已知点和圆心的坐标差，可以算出$\vec{p_i}-\vec{c}_0$向量的方向$\theta_i$，根据该方向在连续变化时的首末差值就能算出缠绕数：$$w=\frac{\theta_\text{final}-\theta_\text{initial}}{2\pi}$$ 如果该缠绕数等于+1或者-1，这就有可能是一个顺时针或者逆时针的圆。其它情况下，该曲线即被判定为不合格：如果是0，可能是月牙形或者8字形；如果大于2，有可能转了很多圈；如果是半整数，意味着曲线恰好经过了它的中心。
5. 修正圆心。通过梯度迭代的方法，修正圆心$\vec{c}$，以最小化平方偏差：$$\eta_\text{SE}(\vec{c})=\oint||\vec{p}_i-\vec{c}||^2\cdot|d\theta_i(\vec{c})|$$ 此平方偏差的根号也被用于衡量所绘曲线是否标准。
6. 频谱分析。考察以下复积分(n是正整数)：$$F_n=\oint||\vec{p}_i-\vec{c}||\cdot e^{ ni\theta_i}\cdot|d\theta_i|$$ 这一系列积分值的模长即是在屏幕中显示的频谱曲线的由来。
7. 特别地：
  - 2倍频的幅角数据被用来衡量圆形向什么方向伸长和收缩；
  - 360倍频以上的高频频谱之和占总频谱的比例被用于衡量曲线的粗糙程度。
